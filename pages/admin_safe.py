# -*- coding: utf-8 -*-
"""
P√°gina de Administra√ß√£o - Vers√£o Segura (Sem openpyxl)
Painel para gerenciar ingredientes, embalagens e usu√°rios
"""

import streamlit as st
from datetime import datetime

# Lista de administradores autorizados
ADMINS = [
    "weber.melo@gmail.com",    # Super Admin Principal
    "weber@marmitasfit.com",   # Backup
    "admin@marmitasfit.com",   # Admin secund√°rio
    "demo@marmitasfit.com"     # Para testes
]

def is_admin(user_email):
    """Verifica se o usu√°rio √© administrador"""
    return user_email.lower() in [admin.lower() for admin in ADMINS]

def show_admin_page():
    """P√°gina principal de administra√ß√£o - Vers√£o Segura"""
    
    # Verificar autentica√ß√£o
    if 'user' not in st.session_state:
        st.error("üîê Acesso restrito. Fa√ßa login primeiro.")
        return
    
    user_email = st.session_state.user.get('email', '')
    
    # Verificar permiss√µes de admin
    if not is_admin(user_email):
        st.error("üö´ Acesso negado. Voc√™ n√£o tem permiss√µes de administrador.")
        st.info(f"üë§ Usu√°rio atual: {user_email}")
        return
    
    # Interface de administra√ß√£o
    st.title("üëë Painel de Administra√ß√£o")
    st.success(f"üîì Acesso autorizado: {user_email}")
    
    # Tabs principais
    tab1, tab2, tab3 = st.tabs(["üì• Templates", "üì§ Uploads & Limpeza", "üìä Estat√≠sticas"])
    
    with tab1:
        show_templates_safe()
    
    with tab2:
        show_uploads_safe()
        st.markdown("---")
        show_cleanup_tools()
    
    with tab3:
        show_stats_safe()

def show_templates_safe():
    """Se√ß√£o de templates - vers√£o segura"""
    
    st.header("üì• Templates CSV")
    st.info("üí° Baixe os templates para facilitar o preenchimento de dados")
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.subheader("ü•ï Ingredientes")
        st.markdown("""
        **Template para:**
        - Nome e categoria
        - Pre√ßos atualizados
        - Informa√ß√µes nutricionais
        - Unidades de medida
        """)
        
        csv_ingredientes = """Nome,Categoria,Preco,Unid_Receita,Unid_Compra,Kcal_Unid,Fator_Conv,Ativo,Observacoes
Frango peito,Proteina Animal,18.90,g,kg,1.65,1000,TRUE,Sem pele congelado
Arroz integral,Carboidrato,8.90,g,kg,1.11,1000,TRUE,Grao longo tipo 1
Brocolis,Vegetal,6.50,g,kg,0.34,1000,TRUE,Fresco preco medio
Azeite extra virgem,Gordura,12.00,ml,L,8.84,1000,TRUE,Primeira prensagem
Sal refinado,Tempero,1.20,g,kg,0.00,1000,TRUE,Iodado"""
        
        st.download_button(
            label="üì• Download Ingredientes (CSV)",
            data=csv_ingredientes.encode('utf-8-sig'),
            file_name=f"ingredientes_template_{datetime.now().strftime('%Y%m%d')}.csv",
            mime="text/csv",
            use_container_width=True
        )
    
    with col2:
        st.subheader("üì¶ Embalagens")
        st.markdown("""
        **Template para:**
        - Tipos de embalagens
        - Pre√ßos unit√°rios
        - Capacidades
        - Categorias
        """)
        
        csv_embalagens = """Nome,Tipo,Preco,Capacidade_ml,Categoria,Ativo,Descricao
Marmita 500ml,descartavel,0.50,500,principal,TRUE,PP transparente com tampa
Marmita 750ml,descartavel,0.65,750,principal,TRUE,PP transparente com tampa
Marmita 1000ml,descartavel,0.80,1000,principal,TRUE,PP transparente com tampa
Pote sobremesa 150ml,descartavel,0.25,150,complemento,TRUE,Para doces e frutas
Talher plastico,utensilio,0.08,0,utensilio,TRUE,Garfo + faca + colher
Guardanapo,higiene,0.05,0,higiene,TRUE,Papel 20x20cm
Sacola plastica,transporte,0.12,0,transporte,TRUE,30x40cm alca camiseta"""
        
        st.download_button(
            label="üì• Download Embalagens (CSV)",
            data=csv_embalagens.encode('utf-8-sig'),
            file_name=f"embalagens_template_{datetime.now().strftime('%Y%m%d')}.csv",
            mime="text/csv",
            use_container_width=True
        )
    
    with col3:
        st.subheader("üè† Custos Fixos")
        st.markdown("""
        **Template para:**
        - Energia, g√°s, √°gua
        - Aluguel e m√£o de obra
        - Rateio por marmita
        - C√°lculo autom√°tico
        """)
        
        csv_custos = """Categoria,Item,Custo_Mensal,Rateio_por_Marmita,Descricao
Energia,Conta de luz,150.00,0.30,Fogao geladeira freezer
Gas,Botijao 13kg,80.00,0.16,Consumo medio mensal
Agua,Conta de agua,60.00,0.12,Limpeza e preparo
Aluguel,Espaco cozinha,800.00,1.60,Proporcional ao uso
Mao de obra,Salario proprio,2000.00,4.00,Base 500 marmitas por mes
TOTAL,,3090.00,6.18,Base 500 marmitas por mes"""
        
        st.download_button(
            label="üì• Download Custos (CSV)",
            data=csv_custos.encode('utf-8-sig'),
            file_name=f"custos_fixos_template_{datetime.now().strftime('%Y%m%d')}.csv",
            mime="text/csv",
            use_container_width=True
        )
    
    with col4:
        st.subheader("üìù Receitas")
        st.markdown("""
        **Template para:**
        - Nome da receita
        - Ingredientes e quantidades
        - Pre√ßo de custo
        - Informa√ß√µes nutricionais
        """)
        
        csv_receitas = """Nome,Categoria,Ingredientes_JSON,Porcoes,Calorias_Porcao,Preco_Custo,Margem_Lucro,Preco_Sugerido,Ativo,Observacoes
Frango Grelhado com Arroz,Fitness,"{""frango_peito"":200_""arroz_integral"":100_""brocolis"":80_""azeite"":5}",1,420,8.50,40,11.90,TRUE,Rica em proteina
Salada de Quinoa,Vegano,"{""quinoa"":80_""tomate"":60_""pepino"":40_""azeite"":10}",1,285,6.20,40,8.68,TRUE,Rica em fibras
Peixe com Legumes,Light,"{""tilapia"":150_""cenoura"":60_""abobrinha"":60_""azeite"":5}",1,320,9.80,40,13.72,TRUE,Baixa caloria"""
        
        st.download_button(
            label="üì• Download Receitas (CSV)",
            data=csv_receitas.encode('utf-8-sig'),
            file_name=f"receitas_template_{datetime.now().strftime('%Y%m%d')}.csv",
            mime="text/csv",
            use_container_width=True
        )
    
    # Instru√ß√µes de uso
    st.markdown("---")
    st.subheader("üìã Como usar os templates:")
    
    with st.expander("üìñ Instru√ß√µes detalhadas"):
        st.markdown("""
        ### üéØ Passo a passo:
        
        1. **üì• Baixe** o template desejado (formato CSV)
        2. **üìù Abra** no Excel ou Google Sheets
        3. **‚úèÔ∏è Preencha** os dados nas colunas
        4. **üíæ Salve** como CSV
        5. **üì§ Contate** o administrador para fazer upload
        6. **‚úÖ Confirme** a importa√ß√£o
        
        ### ‚ö†Ô∏è Regras importantes:
        
        - **N√£o altere** os nomes das colunas
        - **Mantenha** os tipos de dados (texto, n√∫mero, verdadeiro/falso)
        - **Use pontos** para decimais (ex: 18.90)
        - **Ative/Desative** com TRUE/FALSE
        - **Teste primeiro** com poucos registros
        
        ### üîÑ Frequ√™ncia de atualiza√ß√£o:
        
        - **Ingredientes:** Mensal (pre√ßos de mercado)
        - **Embalagens:** Trimestral (novos fornecedores)
        - **Custos Fixos:** Conforme necess√°rio
        - **Receitas:** Conforme cria√ß√£o de novos pratos
        
        ### üìù Formato especial para Receitas:
        
        - **Ingredientes_JSON:** Use formato `{"ingrediente":quantidade_"outro":quantidade}`
        - **Margem_Lucro:** Porcentagem (ex: 40 para 40%)
        - **Exemplo:** `{"frango_peito":200_"arroz":100_"brocolis":50}`
        """)
    
    # FERRAMENTAS DE EMERG√äNCIA AQUI (mais vis√≠vel)
    st.markdown("---")
    st.subheader("üö® ATEN√á√ÉO: Limpeza de Dados")
    
    total_ingredients = len(st.session_state.get('demo_ingredients', []))
    if total_ingredients > 10:
        st.error(f"‚ö†Ô∏è PROBLEMA DETECTADO: {total_ingredients} ingredientes duplicados!")
        st.info("üí° Use os bot√µes abaixo para resolver:")
        
        col1, col2 = st.columns(2)
        
        with col1:
            if st.button("üóëÔ∏è LIMPAR DUPLICATAS", key="fix_duplicates_now", type="primary"):
                ingredientes_unicos = []
                nomes_vistos = set()
                
                for ing in st.session_state.demo_ingredients:
                    nome = ing.get('Nome', '')
                    if nome and nome not in nomes_vistos and str(nome).lower() not in ['none', 'nan', '']:
                        ingrediente_limpo = {
                            'Nome': nome,
                            'Categoria': ing.get('Categoria', 'Outros'),
                            'Unidade_Receita': ing.get('Unidade_Receita', 'g'),
                            'Unidade_Compra': ing.get('Unidade_Compra', 'kg'),
                            'Preco_Padrao': float(ing.get('Preco_Padrao', 0)),
                            'Kcal_Por_Unidade_Receita': float(ing.get('Kcal_Por_Unidade_Receita', 0)),
                            'Fator_Conversao': float(ing.get('Fator_Conversao', 1000))
                        }
                        ingredientes_unicos.append(ingrediente_limpo)
                        nomes_vistos.add(nome)
                
                st.session_state.demo_ingredients = ingredientes_unicos
                st.success(f"‚úÖ CORRIGIDO! {len(ingredientes_unicos)} ingredientes √∫nicos.")
                st.balloons()
                st.rerun()
        
        with col2:
            if st.button("üîÑ RESETAR DADOS", key="reset_all_data"):
                st.session_state.demo_ingredients = [
                    {'Nome': 'Frango (peito)', 'Categoria': 'Prote√≠na Animal', 'Unidade_Receita': 'g', 'Unidade_Compra': 'kg', 'Preco_Padrao': 18.9, 'Kcal_Por_Unidade_Receita': 1.65, 'Fator_Conversao': 1000},
                    {'Nome': 'Arroz integral', 'Categoria': 'Carboidrato', 'Unidade_Receita': 'g', 'Unidade_Compra': 'kg', 'Preco_Padrao': 8.9, 'Kcal_Por_Unidade_Receita': 1.11, 'Fator_Conversao': 1000},
                    {'Nome': 'Br√≥colis', 'Categoria': 'Vegetal', 'Unidade_Receita': 'g', 'Unidade_Compra': 'kg', 'Preco_Padrao': 8.9, 'Kcal_Por_Unidade_Receita': 0.34, 'Fator_Conversao': 1000},
                ]
                st.success("‚úÖ RESETADO! Dados limpos.")
                st.rerun()
    else:
        st.success(f"‚úÖ Dados OK: {total_ingredients} ingredientes")

def show_uploads_safe():
    """Se√ß√£o de uploads CSV - vers√£o segura"""
    
    st.header("üì§ Upload de Dados")
    st.info("üìã Fa√ßa upload dos templates CSV preenchidos para popular o banco de dados")
    
    # Tabs para diferentes tipos de upload
    tab1, tab2, tab3, tab4 = st.tabs(["ü•ï Ingredientes", "üì¶ Embalagens", "üè† Custos Fixos", "üìù Receitas"])
    
    with tab1:
        upload_ingredientes_safe()
    
    with tab2:
        upload_embalagens_safe()
    
    with tab3:
        upload_custos_fixos_safe()
    
    with tab4:
        upload_receitas_safe()
    
    # Se√ß√£o de emerg√™ncia para limpeza r√°pida
    st.markdown("---")
    st.subheader("üö® Limpeza R√°pida de Emerg√™ncia")
    
    total_ingredients = len(st.session_state.get('demo_ingredients', []))
    if total_ingredients > 10:
        st.error(f"‚ö†Ô∏è Detectados {total_ingredients} ingredientes (poss√≠vel duplica√ß√£o!)")
        
        col1, col2 = st.columns(2)
        
        with col1:
            if st.button("üóëÔ∏è LIMPAR DUPLICATAS AGORA", key="emergency_cleanup", type="primary"):
                if st.session_state.get('demo_ingredients'):
                    ingredientes_unicos = []
                    nomes_vistos = set()
                    
                    for ing in st.session_state.demo_ingredients:
                        nome = ing.get('Nome', '')
                        if nome and nome not in nomes_vistos and str(nome).lower() not in ['none', 'nan', '']:
                            # Garantir estrutura correta
                            ingrediente_limpo = {
                                'Nome': nome,
                                'Categoria': ing.get('Categoria', 'Outros'),
                                'Unidade_Receita': ing.get('Unidade_Receita', 'g'),
                                'Unidade_Compra': ing.get('Unidade_Compra', 'kg'),
                                'Preco_Padrao': float(ing.get('Preco_Padrao', 0)),
                                'Kcal_Por_Unidade_Receita': float(ing.get('Kcal_Por_Unidade_Receita', 0)),
                                'Fator_Conversao': float(ing.get('Fator_Conversao', 1000))
                            }
                            ingredientes_unicos.append(ingrediente_limpo)
                            nomes_vistos.add(nome)
                    
                    st.session_state.demo_ingredients = ingredientes_unicos
                    st.success(f"‚úÖ LIMPEZA CONCLU√çDA! {len(ingredientes_unicos)} ingredientes √∫nicos mantidos.")
                    st.balloons()
                    st.rerun()
        
        with col2:
            if st.button("üîÑ RESETAR TUDO", key="emergency_reset"):
                st.session_state.demo_ingredients = [
                    {'Nome': 'Frango (peito)', 'Categoria': 'Prote√≠na Animal', 'Unidade_Receita': 'g', 'Unidade_Compra': 'kg', 'Preco_Padrao': 18.9, 'Kcal_Por_Unidade_Receita': 1.65, 'Fator_Conversao': 1000},
                    {'Nome': 'Arroz integral', 'Categoria': 'Carboidrato', 'Unidade_Receita': 'g', 'Unidade_Compra': 'kg', 'Preco_Padrao': 8.9, 'Kcal_Por_Unidade_Receita': 1.11, 'Fator_Conversao': 1000},
                    {'Nome': 'Br√≥colis', 'Categoria': 'Vegetal', 'Unidade_Receita': 'g', 'Unidade_Compra': 'kg', 'Preco_Padrao': 8.9, 'Kcal_Por_Unidade_Receita': 0.34, 'Fator_Conversao': 1000},
                ]
                st.success("‚úÖ RESETADO! Volte aos 3 ingredientes iniciais.")
                st.rerun()
    else:
        st.success(f"‚úÖ {total_ingredients} ingredientes - quantidade normal")

def upload_ingredientes_safe():
    """Upload de ingredientes CSV - vers√£o segura"""
    
    st.subheader("ü•ï Upload Ingredientes")
    
    uploaded_file = st.file_uploader(
        "Selecione o arquivo CSV de ingredientes",
        type=['csv'],
        key="ingredientes_upload_safe",
        help="Use o template CSV baixado na aba Templates"
    )
    
    if uploaded_file is not None:
        try:
            # Usar pandas com engine Python (sem Excel dependencies)
            import pandas as pd
            df = pd.read_csv(uploaded_file, encoding='utf-8-sig', engine='python')
            
            st.write("üìã **Preview dos dados:**")
            st.dataframe(df.head())
            
            st.write(f"üìä **Total de registros:** {len(df)}")
            
            # Debug: Mostrar informa√ß√µes sobre o DataFrame
            with st.expander("üîç Debug - Informa√ß√µes do arquivo"):
                st.write("**Colunas encontradas:**")
                st.write(list(df.columns))
                st.write("**Tipos de dados:**")
                st.write(df.dtypes)
                st.write("**Primeiras 3 linhas (raw):**")
                for i in range(min(3, len(df))):
                    st.write(f"Linha {i}: {df.iloc[i].to_dict()}")
                st.write("**Valores √∫nicos na coluna 'Nome' (primeiros 10):**")
                st.write(df['Nome'].dropna().head(10).tolist())
            
            # Validar colunas obrigat√≥rias
            required_columns = ['Nome', 'Categoria', 'Preco', 'Unid_Receita', 'Unid_Compra', 'Kcal_Unid', 'Fator_Conv', 'Ativo']
            missing_columns = [col for col in required_columns if col not in df.columns]
            
            if missing_columns:
                st.error(f"‚ùå Colunas obrigat√≥rias n√£o encontradas: {', '.join(missing_columns)}")
                st.info("üí° Baixe o template correto na aba Templates")
                return
            
            # Valida√ß√£o de dados
            validation_errors = validate_ingredientes_data(df)
            if validation_errors:
                st.warning("‚ö†Ô∏è **Problemas encontrados nos dados:**")
                for error in validation_errors:
                    st.write(f"- {error}")
            
            # Bot√£o para confirmar upload
            if st.button("‚úÖ Confirmar Upload Ingredientes", key="confirm_ingredientes_safe"):
                with st.spinner("Salvando ingredientes..."):
                    success_count = save_ingredientes_to_session(df)
                    if success_count > 0:
                        st.success(f"üéâ {success_count} ingredientes salvos com sucesso!")
                        st.balloons()
                    else:
                        st.error("‚ùå Erro ao salvar ingredientes")
                        
        except Exception as e:
            st.error(f"‚ùå Erro ao processar arquivo: {str(e)}")
            st.info("üí° Verifique se o arquivo est√° no formato CSV correto")

def upload_embalagens_safe():
    """Upload de embalagens CSV - vers√£o segura"""
    
    st.subheader("üì¶ Upload Embalagens")
    
    uploaded_file = st.file_uploader(
        "Selecione o arquivo CSV de embalagens",
        type=['csv'],
        key="embalagens_upload_safe",
        help="Use o template CSV baixado na aba Templates"
    )
    
    if uploaded_file is not None:
        try:
            import pandas as pd
            df = pd.read_csv(uploaded_file, encoding='utf-8-sig', engine='python')
            
            st.write("üìã **Preview dos dados:**")
            st.dataframe(df.head())
            
            st.write(f"üìä **Total de registros:** {len(df)}")
            
            # Validar colunas obrigat√≥rias
            required_columns = ['Nome', 'Tipo', 'Preco', 'Capacidade_ml', 'Categoria', 'Ativo']
            missing_columns = [col for col in required_columns if col not in df.columns]
            
            if missing_columns:
                st.error(f"‚ùå Colunas obrigat√≥rias n√£o encontradas: {', '.join(missing_columns)}")
                return
            
            # Bot√£o para confirmar upload
            if st.button("‚úÖ Confirmar Upload Embalagens", key="confirm_embalagens_safe"):
                with st.spinner("Salvando embalagens..."):
                    success_count = save_embalagens_to_session(df)
                    if success_count > 0:
                        st.success(f"üéâ {success_count} embalagens salvas com sucesso!")
                        st.balloons()
                    else:
                        st.error("‚ùå Erro ao salvar embalagens")
                        
        except Exception as e:
            st.error(f"‚ùå Erro ao processar arquivo: {str(e)}")

def upload_custos_fixos_safe():
    """Upload de custos fixos CSV - vers√£o segura"""
    
    st.subheader("üè† Upload Custos Fixos")
    
    uploaded_file = st.file_uploader(
        "Selecione o arquivo CSV de custos fixos",
        type=['csv'],
        key="custos_upload_safe",
        help="Use o template CSV baixado na aba Templates"
    )
    
    if uploaded_file is not None:
        try:
            import pandas as pd
            df = pd.read_csv(uploaded_file, encoding='utf-8-sig', engine='python')
            
            st.write("üìã **Preview dos dados:**")
            st.dataframe(df.head())
            
            st.write(f"üìä **Total de registros:** {len(df)}")
            
            # Validar colunas obrigat√≥rias
            required_columns = ['Categoria', 'Item', 'Custo_Mensal', 'Rateio_por_Marmita']
            missing_columns = [col for col in required_columns if col not in df.columns]
            
            if missing_columns:
                st.error(f"‚ùå Colunas obrigat√≥rias n√£o encontradas: {', '.join(missing_columns)}")
                return
            
            # Bot√£o para confirmar upload
            if st.button("‚úÖ Confirmar Upload Custos Fixos", key="confirm_custos_safe"):
                with st.spinner("Salvando custos fixos..."):
                    success_count = save_custos_to_session(df)
                    if success_count > 0:
                        st.success(f"üéâ {success_count} custos fixos salvos com sucesso!")
                        st.balloons()
                    else:
                        st.error("‚ùå Erro ao salvar custos fixos")
                        
        except Exception as e:
            st.error(f"‚ùå Erro ao processar arquivo: {str(e)}")

def upload_receitas_safe():
    """Upload de receitas CSV - vers√£o segura"""
    
    st.subheader("üìù Upload Receitas")
    
    uploaded_file = st.file_uploader(
        "Selecione o arquivo CSV de receitas",
        type=['csv'],
        key="receitas_upload_safe",
        help="Use o template CSV baixado na aba Templates"
    )
    
    if uploaded_file is not None:
        try:
            import pandas as pd
            df = pd.read_csv(uploaded_file, encoding='utf-8-sig', engine='python')
            
            st.write("üìã **Preview dos dados:**")
            st.dataframe(df.head())
            
            st.write(f"üìä **Total de registros:** {len(df)}")
            
            # Validar colunas obrigat√≥rias
            required_columns = ['Nome', 'Categoria', 'Ingredientes_JSON', 'Porcoes', 'Calorias_Porcao', 'Preco_Custo', 'Ativo']
            missing_columns = [col for col in required_columns if col not in df.columns]
            
            if missing_columns:
                st.error(f"‚ùå Colunas obrigat√≥rias n√£o encontradas: {', '.join(missing_columns)}")
                return
            
            # Valida√ß√£o especial para receitas
            validation_errors = validate_receitas_data(df)
            if validation_errors:
                st.warning("‚ö†Ô∏è **Problemas encontrados nos dados:**")
                for error in validation_errors:
                    st.write(f"- {error}")
            
            # Bot√£o para confirmar upload
            if st.button("‚úÖ Confirmar Upload Receitas", key="confirm_receitas_safe"):
                with st.spinner("Salvando receitas..."):
                    success_count = save_receitas_to_session(df)
                    if success_count > 0:
                        st.success(f"üéâ {success_count} receitas salvas com sucesso!")
                        st.balloons()
                    else:
                        st.error("‚ùå Erro ao salvar receitas")
                        
        except Exception as e:
            st.error(f"‚ùå Erro ao processar arquivo: {str(e)}")

def validate_ingredientes_data(df):
    """Valida dados de ingredientes"""
    errors = []
    
    for idx, row in df.iterrows():
        linha = idx + 2  # +2 porque pandas come√ßa em 0 e tem header
        
        # Validar pre√ßo
        try:
            preco = float(row['Preco'])
            if preco <= 0:
                errors.append(f"Linha {linha}: Pre√ßo deve ser maior que zero")
        except:
            errors.append(f"Linha {linha}: Pre√ßo inv√°lido")
        
        # Validar ativo
        if str(row['Ativo']).upper() not in ['TRUE', 'FALSE']:
            errors.append(f"Linha {linha}: Ativo deve ser TRUE ou FALSE")
    
    return errors[:10]  # Limitar a 10 erros para n√£o poluir a tela

def validate_receitas_data(df):
    """Valida dados de receitas"""
    errors = []
    
    for idx, row in df.iterrows():
        linha = idx + 2
        
        # Validar JSON de ingredientes (formato simplificado)
        ingredientes_str = str(row['Ingredientes_JSON'])
        if not (ingredientes_str.startswith('{') and ingredientes_str.endswith('}')):
            errors.append(f"Linha {linha}: Formato de ingredientes inv√°lido (deve come√ßar com {{ e terminar com }})")
        
        # Validar por√ß√µes
        try:
            porcoes = int(row['Porcoes'])
            if porcoes <= 0:
                errors.append(f"Linha {linha}: Por√ß√µes deve ser maior que zero")
        except:
            errors.append(f"Linha {linha}: Por√ß√µes inv√°lido")
    
    return errors[:10]

def save_ingredientes_to_session(df):
    """Salva ingredientes no session state E Firebase - VERS√ÉO COMPLETA"""
    try:
        # Limpar ingredientes existentes para evitar duplicatas
        st.session_state.demo_ingredients = []
        
        success_count = 0
        firebase_success_count = 0
        failed_rows = []
        
        # PASSO 1: Limpar todos os ingredientes antigos do Firebase se for admin
        if 'user' in st.session_state:
            clear_all_user_ingredients_from_firebase()
        
        for idx, row in df.iterrows():
            try:
                # Validar dados linha por linha
                nome = str(row['Nome']).strip() if pd.notna(row['Nome']) else ''
                categoria = str(row['Categoria']).strip() if pd.notna(row['Categoria']) else ''
                
                # Pular linhas vazias
                if not nome or nome.lower() == 'nan' or not categoria or categoria.lower() == 'nan':
                    continue
                
                # Converter pre√ßo com tratamento de erro
                try:
                    preco = float(row['Preco']) if pd.notna(row['Preco']) else 0.0
                except:
                    preco = 0.0
                
                # Converter calorias com tratamento de erro
                try:
                    kcal_unid = float(row['Kcal_Unid']) if pd.notna(row['Kcal_Unid']) else 0.0
                except:
                    kcal_unid = 0.0
                
                # Converter fator de convers√£o
                try:
                    fator_conv = float(row['Fator_Conv']) if pd.notna(row['Fator_Conv']) else 1.0
                except:
                    fator_conv = 1.0
                
                # Estrutura COMPAT√çVEL com o app (Nome mai√∫sculo, Preco_Padrao, etc.)
                ingredient_data_compatible = {
                    # Estrutura ANTIGA que o app espera
                    'Nome': nome,
                    'Categoria': categoria,
                    'Unidade_Receita': str(row['Unid_Receita']).strip() if pd.notna(row['Unid_Receita']) else 'g',
                    'Unidade_Compra': str(row['Unid_Compra']).strip() if pd.notna(row['Unid_Compra']) else 'kg',
                    'Preco_Padrao': preco,
                    'Kcal_Por_Unidade_Receita': kcal_unid,
                    'Fator_Conversao': fator_conv,
                    'Ativo': str(row['Ativo']).upper() == 'TRUE' if pd.notna(row['Ativo']) else True,
                    'Observacoes': str(row.get('Observacoes', '')).strip() if pd.notna(row.get('Observacoes', '')) else '',
                    
                    # Estrutura NOVA tamb√©m (para Firebase)
                    'nome': nome,
                    'categoria': categoria,
                    'unid_receita': str(row['Unid_Receita']).strip() if pd.notna(row['Unid_Receita']) else 'g',
                    'unid_compra': str(row['Unid_Compra']).strip() if pd.notna(row['Unid_Compra']) else 'kg',
                    'preco': preco,
                    'kcal_unid': kcal_unid,
                    'fator_conv': fator_conv,
                    'ativo': str(row['Ativo']).upper() == 'TRUE' if pd.notna(row['Ativo']) else True,
                    'observacoes': str(row.get('Observacoes', '')).strip() if pd.notna(row.get('Observacoes', '')) else ''
                }
                
                # Salvar no session state (estrutura compat√≠vel)
                st.session_state.demo_ingredients.append(ingredient_data_compatible)
                success_count += 1
                
                # SALVAR NO FIREBASE (SEM IMPORT CIRCULAR)
                try:
                    if save_ingredient_to_firebase_direct(ingredient_data_compatible):
                        firebase_success_count += 1
                        st.success(f"üî• '{nome}' salvo no Firebase!")
                    else:
                        st.error(f"‚ùå Falha ao salvar '{nome}' no Firebase")
                except Exception as firebase_error:
                    st.error(f"‚ùå ERRO FIREBASE '{nome}': {firebase_error}")
                    st.code(str(firebase_error))  # Mostrar erro completo
                    # N√ÉO usar pass - queremos ver os erros!
                
            except Exception as row_error:
                failed_rows.append(f"Linha {idx+2}: {str(row_error)}")
                continue
        
        # Mostrar resultados
        if firebase_success_count > 0:
            st.success(f"üî• {firebase_success_count} ingredientes salvos no Firebase!")
            st.success(f"üíæ {success_count} ingredientes salvos localmente!")
        else:
            st.warning(f"üíæ {success_count} ingredientes salvos apenas localmente (Firebase indispon√≠vel)")
        
        # Mostrar erros se houver
        if failed_rows:
            st.warning("‚ö†Ô∏è Algumas linhas n√£o puderam ser importadas:")
            for error in failed_rows[:5]:  # Mostrar apenas os primeiros 5 erros
                st.write(f"- {error}")
            if len(failed_rows) > 5:
                st.write(f"... e mais {len(failed_rows)-5} erros")
        
        return success_count
        
    except Exception as e:
        st.error(f"Erro geral no upload: {str(e)}")
        import traceback
        st.code(traceback.format_exc())
        return 0

def save_ingredient_to_firebase_direct(ingredient):
    """Salva ingrediente diretamente no Firebase SEM import circular"""
    
    # Verificar se usu√°rio est√° logado
    if 'user' not in st.session_state:
        st.error("‚ùå Usu√°rio n√£o logado")
        return False
    
    try:
        # Import direto do cliente
        from utils.firestore_client import get_firestore_client
        
        # Obter cliente Firestore
        db = get_firestore_client()
        if not db:
            st.error("‚ùå Cliente Firestore n√£o inicializado")
            return False
        
        # Verificar e configurar token
        if 'token' not in st.session_state.user or not st.session_state.user['token']:
            st.error("‚ùå Token de autentica√ß√£o n√£o encontrado")
            return False
        
        # Configurar autentica√ß√£o
        token = st.session_state.user['token']
        db.set_auth_token(token)
        st.info(f"üîë Token configurado: {token[:20]}...")
        
        # Preparar dados
        user_id = st.session_state.user['uid']
        collection_path = f'users/{user_id}/ingredients'
        
        # Dados completos para Firebase
        ingredient_data = ingredient.copy()
        ingredient_data['user_id'] = user_id
        ingredient_data['created_at'] = datetime.now().isoformat()
        
        st.info(f"üìç Salvando em: {collection_path}")
        st.info(f"üìã Item: {ingredient_data.get('nome', 'N/A')} - {ingredient_data.get('categoria', 'N/A')}")
        
        # Salvar no Firebase via REST API
        st.info(f"üî• Chamando db.collection('{collection_path}').add()")
        result = db.collection(collection_path).add(ingredient_data)
        
        st.info(f"üîç Result type: {type(result)}")
        st.info(f"üîç Result value: {result}")
        
        if result:
            st.success(f"‚úÖ Firebase: '{ingredient_data.get('nome', 'N/A')}' salvo com sucesso!")
            st.info(f"üìÑ Document ID: {result}")
            return True
        else:
            st.error("‚ùå Firebase: Falha na resposta (resultado vazio)")
            return False
            
    except Exception as e:
        st.error(f"‚ùå EXCE√á√ÉO no save Firebase: {str(e)}")
        
        # Mostrar stack trace completo para debug
        import traceback
        error_details = traceback.format_exc()
        st.code(f"Stack trace:\n{error_details}")
        
        return False

def clear_all_user_ingredients_from_firebase():
    """Remove todos os ingredientes do usu√°rio do Firebase antes de upload"""
    try:
        if 'user' not in st.session_state:
            return False
            
        from utils.firestore_client import get_firestore_client
        import requests
        
        db = get_firestore_client()
        if db and 'token' in st.session_state.user:
            db.set_auth_token(st.session_state.user['token'])
            
            user_id = st.session_state.user['uid']
            collection_path = f'users/{user_id}/ingredients'
            
            # URL para listar documentos
            url = f"{db.base_url}/{collection_path}"
            response = requests.get(url, headers=db._get_headers())
            
            if response.status_code == 200:
                data = response.json()
                if 'documents' in data:
                    # Deletar cada documento encontrado
                    deleted_count = 0
                    for doc in data['documents']:
                        doc_path = doc['name']  # Caminho completo do documento
                        delete_response = requests.delete(doc_path, headers=db._get_headers())
                        if delete_response.status_code in [200, 204]:
                            deleted_count += 1
                    
                    print(f"DEBUG: Removidos {deleted_count} ingredientes antigos do Firebase")
                    return True
            
    except Exception as e:
        print(f"DEBUG: Erro ao limpar ingredientes antigos: {e}")
        pass  # N√£o falhar o upload por causa disso
    
    return False

def save_embalagens_to_session(df):
    """Salva embalagens no session state (vers√£o demo)"""
    try:
        if 'demo_embalagens' not in st.session_state:
            st.session_state.demo_embalagens = []
        
        success_count = 0
        
        for _, row in df.iterrows():
            embalagem_data = {
                'id': f"upload_emb_{len(st.session_state.demo_embalagens)}_{success_count}",
                'nome': str(row['Nome']).strip(),
                'tipo': str(row['Tipo']).strip(),
                'preco': float(row['Preco']),
                'capacidade_ml': int(row['Capacidade_ml']) if row['Capacidade_ml'] != 0 else 0,
                'categoria': str(row['Categoria']).strip(),
                'ativo': str(row['Ativo']).upper() == 'TRUE',
                'descricao': str(row.get('Descricao', '')).strip(),
                'source': 'upload_csv'
            }
            
            st.session_state.demo_embalagens.append(embalagem_data)
            success_count += 1
        
        return success_count
        
    except Exception as e:
        st.error(f"Erro ao salvar embalagens: {str(e)}")
        return 0

def save_custos_to_session(df):
    """Salva custos fixos no session state (vers√£o demo)"""
    try:
        if 'demo_custos_fixos' not in st.session_state:
            st.session_state.demo_custos_fixos = []
        
        success_count = 0
        
        for _, row in df.iterrows():
            custo_data = {
                'id': f"upload_custo_{len(st.session_state.demo_custos_fixos)}_{success_count}",
                'categoria': str(row['Categoria']).strip(),
                'item': str(row['Item']).strip(),
                'custo_mensal': float(row['Custo_Mensal']),
                'rateio_por_marmita': float(row['Rateio_por_Marmita']),
                'descricao': str(row.get('Descricao', '')).strip(),
                'source': 'upload_csv'
            }
            
            st.session_state.demo_custos_fixos.append(custo_data)
            success_count += 1
        
        return success_count
        
    except Exception as e:
        st.error(f"Erro ao salvar custos fixos: {str(e)}")
        return 0

def save_receitas_to_session(df):
    """Salva receitas no session state (vers√£o demo)"""
    try:
        if 'demo_recipes' not in st.session_state:
            st.session_state.demo_recipes = []
        
        success_count = 0
        
        for _, row in df.iterrows():
            # Converter JSON simplificado de ingredientes
            ingredientes_str = str(row['Ingredientes_JSON'])
            ingredientes_dict = parse_simple_json(ingredientes_str)
            
            receita_data = {
                'id': f"upload_receita_{len(st.session_state.demo_recipes)}_{success_count}",
                'nome': str(row['Nome']).strip(),
                'categoria': str(row['Categoria']).strip(),
                'ingredientes': ingredientes_dict,
                'porcoes': int(row['Porcoes']),
                'calorias_porcao': float(row['Calorias_Porcao']),
                'preco_custo': float(row['Preco_Custo']),
                'margem_lucro': float(row.get('Margem_Lucro', 40)),
                'preco_sugerido': float(row.get('Preco_Sugerido', 0)),
                'ativo': str(row['Ativo']).upper() == 'TRUE',
                'observacoes': str(row.get('Observacoes', '')).strip(),
                'source': 'upload_csv'
            }
            
            st.session_state.demo_recipes.append(receita_data)
            success_count += 1
        
        return success_count
        
    except Exception as e:
        st.error(f"Erro ao salvar receitas: {str(e)}")
        return 0

def parse_simple_json(json_str):
    """Parser simples para formato {"item":valor_"item2":valor}"""
    try:
        # Remover chaves
        content = json_str.strip('{}')
        
        # Separar por _
        pairs = content.split('_')
        
        result = {}
        for pair in pairs:
            if ':' in pair:
                # Separar por :
                parts = pair.split(':')
                if len(parts) >= 2:
                    key = parts[0].strip().strip('"')
                    value = float(parts[1].strip())
                    result[key] = value
        
        return result
        
    except Exception as e:
        return {}

def show_cleanup_tools():
    """Ferramentas de limpeza e manuten√ß√£o dos dados"""
    
    st.header("üßπ Ferramentas de Limpeza")
    st.warning("‚ö†Ô∏è Use essas ferramentas para corrigir problemas de dados duplicados!")
    
    # Estat√≠sticas atuais
    st.subheader("üìä Status Atual dos Dados")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        total_ing = len(st.session_state.get('demo_ingredients', []))
        st.metric("ü•ï Total Ingredientes", total_ing)
    
    with col2:
        total_rec = len(st.session_state.get('demo_recipes', []))
        st.metric("üìù Total Receitas", total_rec)
    
    with col3:
        total_emb = len(st.session_state.get('demo_embalagens', []))
        st.metric("üì¶ Total Embalagens", total_emb)
    
    # An√°lise de duplicatas
    st.subheader("üîç An√°lise de Duplicatas")
    
    if st.session_state.get('demo_ingredients'):
        ingredientes = st.session_state.demo_ingredients
        
        # Contar por nome
        nomes = [ing.get('Nome', 'Sem nome') for ing in ingredientes]
        from collections import Counter
        contador_nomes = Counter(nomes)
        
        duplicatas = {nome: count for nome, count in contador_nomes.items() if count > 1}
        
        if duplicatas:
            st.warning(f"‚ö†Ô∏è Encontradas {len(duplicatas)} nomes duplicados:")
            
            for nome, count in list(duplicatas.items())[:10]:  # Mostrar apenas os primeiros 10
                st.write(f"- **{nome}**: {count} ocorr√™ncias")
            
            if len(duplicatas) > 10:
                st.write(f"... e mais {len(duplicatas) - 10} duplicatas")
        else:
            st.success("‚úÖ Nenhuma duplicata encontrada por nome")
        
        # An√°lise de estrutura
        st.subheader("üîß An√°lise de Estrutura")
        
        estruturas_diferentes = {}
        for i, ing in enumerate(ingredientes):
            chaves = tuple(sorted(ing.keys()))
            if chaves not in estruturas_diferentes:
                estruturas_diferentes[chaves] = []
            estruturas_diferentes[chaves].append(i)
        
        if len(estruturas_diferentes) > 1:
            st.warning(f"‚ö†Ô∏è Encontradas {len(estruturas_diferentes)} estruturas diferentes:")
            
            for i, (estrutura, indices) in enumerate(estruturas_diferentes.items()):
                st.write(f"**Estrutura {i+1}** ({len(indices)} ingredientes):")
                st.write(f"Campos: {list(estrutura)}")
                st.write(f"Primeiros ingredientes: {indices[:5]}")
        else:
            st.success("‚úÖ Todos os ingredientes t√™m a mesma estrutura")
    
    # Ferramentas de limpeza
    st.subheader("üõ†Ô∏è Ferramentas de Limpeza")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.write("**ü•ï Ingredientes:**")
        
        if st.button("üóëÔ∏è Remover Duplicatas por Nome", key="remove_duplicates"):
            if st.session_state.get('demo_ingredients'):
                ingredientes_unicos = []
                nomes_vistos = set()
                
                for ing in st.session_state.demo_ingredients:
                    nome = ing.get('Nome', '')
                    if nome and nome not in nomes_vistos:
                        # Garantir estrutura correta
                        ingrediente_limpo = {
                            'Nome': nome,
                            'Categoria': ing.get('Categoria', 'Outros'),
                            'Unidade_Receita': ing.get('Unidade_Receita', 'g'),
                            'Unidade_Compra': ing.get('Unidade_Compra', 'kg'),
                            'Preco_Padrao': float(ing.get('Preco_Padrao', 0)),
                            'Kcal_Por_Unidade_Receita': float(ing.get('Kcal_Por_Unidade_Receita', 0)),
                            'Fator_Conversao': float(ing.get('Fator_Conversao', 1000))
                        }
                        ingredientes_unicos.append(ingrediente_limpo)
                        nomes_vistos.add(nome)
                
                st.session_state.demo_ingredients = ingredientes_unicos
                st.success(f"‚úÖ Limpeza conclu√≠da! {len(ingredientes_unicos)} ingredientes √∫nicos mantidos.")
                st.rerun()
        
        if st.button("üîÑ Resetar Ingredientes", key="reset_ingredients"):
            st.session_state.demo_ingredients = [
                {'Nome': 'Frango (peito)', 'Categoria': 'Prote√≠na Animal', 'Unidade_Receita': 'g', 'Unidade_Compra': 'kg', 'Preco_Padrao': 18.9, 'Kcal_Por_Unidade_Receita': 1.65, 'Fator_Conversao': 1000},
                {'Nome': 'Arroz integral', 'Categoria': 'Carboidrato', 'Unidade_Receita': 'g', 'Unidade_Compra': 'kg', 'Preco_Padrao': 8.9, 'Kcal_Por_Unidade_Receita': 1.11, 'Fator_Conversao': 1000},
                {'Nome': 'Br√≥colis', 'Categoria': 'Vegetal', 'Unidade_Receita': 'g', 'Unidade_Compra': 'kg', 'Preco_Padrao': 8.9, 'Kcal_Por_Unidade_Receita': 0.34, 'Fator_Conversao': 1000},
            ]
            st.success("‚úÖ Ingredientes resetados para os 3 iniciais!")
            st.rerun()
    
    with col2:
        st.write("**üßπ Geral:**")
        
        if st.button("üîÑ Limpar Todos os Dados", key="reset_all"):
            st.session_state.demo_ingredients = []
            st.session_state.demo_recipes = []
            st.session_state.demo_embalagens = []
            st.session_state.demo_custos_fixos = []
            st.success("‚úÖ Todos os dados foram limpos!")
            st.rerun()
        
        if st.button("üîß Corrigir Estrutura dos Dados", key="fix_structure"):
            if st.session_state.get('demo_ingredients'):
                ingredientes_corrigidos = []
                
                for ing in st.session_state.demo_ingredients:
                    # Tentar extrair nome v√°lido
                    nome = ing.get('Nome') or ing.get('nome') or ing.get('name') or 'Ingrediente sem nome'
                    
                    # Pular se nome for None, NaN ou vazio
                    if not nome or str(nome).lower() in ['none', 'nan', '']:
                        continue
                    
                    ingrediente_corrigido = {
                        'Nome': str(nome).strip(),
                        'Categoria': str(ing.get('Categoria') or ing.get('categoria') or 'Outros').strip(),
                        'Unidade_Receita': str(ing.get('Unidade_Receita') or ing.get('unid_receita') or 'g').strip(),
                        'Unidade_Compra': str(ing.get('Unidade_Compra') or ing.get('unid_compra') or 'kg').strip(),
                        'Preco_Padrao': float(ing.get('Preco_Padrao') or ing.get('preco') or 0),
                        'Kcal_Por_Unidade_Receita': float(ing.get('Kcal_Por_Unidade_Receita') or ing.get('kcal_unid') or 0),
                        'Fator_Conversao': float(ing.get('Fator_Conversao') or ing.get('fator_conv') or 1000)
                    }
                    ingredientes_corrigidos.append(ingrediente_corrigido)
                
                st.session_state.demo_ingredients = ingredientes_corrigidos
                st.success(f"‚úÖ Estrutura corrigida! {len(ingredientes_corrigidos)} ingredientes v√°lidos.")
                st.rerun()

def show_stats_safe():
    """Se√ß√£o de estat√≠sticas - vers√£o segura"""
    
    st.header("üìä Estat√≠sticas do Sistema")
    
    # Mock data para demonstra√ß√£o
    st.subheader("üìà M√©tricas de Uso")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.metric("üë• Total Usu√°rios", "1.247", "12 novos")
        st.metric("üíé Assinantes Ativos", "1.189", "4.2%")
        st.metric("üçΩÔ∏è Receitas Criadas", "15.632")
        st.metric("üè≠ Produ√ß√µes Planejadas", "8.947")
    
    with col2:
        st.metric("üí∞ Receita Mensal", "R$ 2.958", "4.2%")
        st.metric("üìà Taxa Convers√£o", "95.3%", "2.1%")
        st.metric("üõí Listas Geradas", "12.458")
        st.metric("üìÑ PDFs Baixados", "9.234")
    
    # Resumo do modelo de neg√≥cio
    st.markdown("---")
    st.subheader("üíº Modelo de Neg√≥cio")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.info("""
        **üí∞ Pre√ßo:**
        R$ 29,90/ano
        
        **üéØ Meta:**
        200k usu√°rios
        
        **üìà Margem:**
        40% nos pre√ßos
        """)
    
    with col2:
        st.success("""
        **üíµ Proje√ß√£o:**
        R$ 5.98M/ano
        
        **üë• Convers√£o:**
        95% dos usu√°rios
        
        **üîÑ Renova√ß√£o:**
        Anual autom√°tica
        """)
    
    with col3:
        st.warning("""
        **üìä Atualiza√ß√µes:**
        Pre√ßos mensais
        
        **üéÅ Diferencial:**
        Sem vers√£o gratuita
        
        **‚ö° Foco:**
        Empreendedores s√©rios
        """)

# Fun√ß√£o para incluir no menu principal
def show_admin_menu_item():
    """Mostra item de menu admin se usu√°rio for administrador"""
    
    if 'user' in st.session_state:
        user_email = st.session_state.user.get('email', '')
        
        if is_admin(user_email):
            return True
    
    return False